<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>StreamPal</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Bungee&display=swap" rel="stylesheet">
<link rel="stylesheet" href="styles.css">
</head>
<body>
<header>
  <div class="brand">
    <h1 class="title-text">ðŸ“º StreamPal</h1>
  </div>
  <div class="row">
    <button id="filtersBtn" class="btn secondary">Filters</button>
    <button id="seenBtn" class="btn secondary">Seen list</button>
  </div>
</header>
<main>

  <div class="layout">
    <!-- Stepper -->
    <aside id="filterDrawer" class="drawer">
      <div class="panel" id="questionnaire">
      <div class="row row--inputs">
        <div style="flex:1;min-width:180px">
          <label>Movie or TV?</label>
          <div class="row" id="typeChips">
            <div class="chip active" data-value="movie">Movie</div>
            <div class="chip" data-value="tv">TV</div>
          </div>
        </div>

        <div style="flex:2;min-width:240px">
          <label>Genres (pick a few)</label>
          <div class="row" id="genreChips"></div>
        </div>

        <div style="flex:1;min-width:180px">
          <label>Release window</label>
          <select id="releaseWindow">
            <option value="">Anything</option>
            <option value="new">New (last 2 years)</option>
            <option value="recent">2015â€“2021</option>
            <option value="classic">Before 2015</option>
          </select>
        </div>
      </div>

      <div class="row row--inputs">
        <div style="flex:2;min-width:240px">
          <label>Streaming services (US)</label>
          <div class="row" id="providerChips"></div>
          <div class="sublabel">Tip: pick the services you actually subscribe to.</div>
        </div>

        <div style="flex:1;min-width:200px">
          <label>Minimum community rating (IMDb)</label>
          <input id="minImdb" type="range" min="0" max="9" step="0.5" value="6.5" oninput="minImdbOut.textContent=this.value">
          <div class="sublabel">â‰¥ <span id="minImdbOut">6.5</span>/10</div>
        </div>

        <div style="flex:1;min-width:200px">
          <label>Vibe</label>
          <select id="mood">
            <option value="">Surprise us</option>
            <option value="feelgood">Feel-good</option>
            <option value="intense">Intense / thrilling</option>
            <option value="smart">Smart / talky</option>
            <option value="spooky">Spooky</option>
            <option value="actiony">Action-packed</option>
          </select>
        </div>
      </div>

        <div class="row row--actions">
          <button class="btn" id="findBtn">Find something to watch</button>
          <button class="btn secondary" id="shuffleBtn" title="Show different matches">Roll again</button>
        </div>
      </div>
    </aside>

    <!-- Results -->
    <div id="results" class="grid"></div>
  </div>
  <aside id="seenDrawer" class="drawer drawer--seen">
    <div class="panel" id="seenList">
      <div class="row row--actions">
        <button class="btn secondary" id="resetListsBtn">Reset list</button>
      </div>
      <div id="seenGrid" class="grid"></div>
    </div>
  </aside>
  <div id="status" class="sublabel"></div>

  <div class="panel">
    <div class="disclaimer">
      Data Â© TMDb; watch-provider availability powered by TMDbâ€™s JustWatch partnership. Ratings via OMDb (IMDb & Rotten Tomatoes when available).
    </div>
  </div>
</main>

<script type="module">
import { providerSlug } from './src/providerSlug.js';

/*** ðŸ”§ CONFIG â€” add your keys ***/
const TMDB_KEY = "f653b3ff00c4561dfaebe995836a28e7";
const OMDB_KEY = "84da1316"; // free 1k/day; upgrade if needed

const state = {
  type: "movie",
  genres: [],
  genreMap: { movie: {}, tv: {} },
  providersUS: [], // [{slug, provider_id, label}]
  chosenProviders: new Set(),
  lastBatch: [],
  pageCursor: 1,
  seen: new Set(
    (JSON.parse(localStorage.getItem("seenIds")||"[]"))
      .map(x => typeof x === "string" ? x.replace(":", "-") : x)
  ),
  kept: new Set(JSON.parse(localStorage.getItem("keptIds")||"[]"))
};

// --- helpers
const $ = (q) => document.querySelector(q);
const el = (tag, props={}) => Object.assign(document.createElement(tag), props);
function toast(msg){ $("#status").textContent = msg; setTimeout(()=>$("#status").textContent="", 4500); }
function toggleChip(chip){
  const v = chip.dataset.value;
  chip.classList.toggle("active");
  if(chip.parentElement.id === "genreChips"){
    chip.classList.contains("active") ? state.genres.push(v) : state.genres = state.genres.filter(x=>x!==v);
  } else if (chip.parentElement.id === "providerChips"){
    chip.classList.contains("active") ? state.chosenProviders.add(v) : state.chosenProviders.delete(v);
  } else if (chip.parentElement.id === "typeChips"){
    [...chip.parentElement.children].forEach(c=>c.classList.remove("active"));
    chip.classList.add("active");
    state.type = v;
    buildGenres(); // reload genre chips for this type
  }
}

function saveSeen(){ localStorage.setItem("seenIds", JSON.stringify([...state.seen])); }
function saveKept(){ localStorage.setItem("keptIds", JSON.stringify([...state.kept])); }

let activeDrawer = null;
function setupDrawer(drawerId, btnId, onOpen){
  const drawer = $(drawerId);
  const btn = $(btnId);
  let focusables = [];
  function trap(e){
    if(e.key === 'Escape') return close();
    if(e.key === 'Tab' && focusables.length){
      const first = focusables[0];
      const last = focusables[focusables.length-1];
      if(e.shiftKey && document.activeElement === first){
        e.preventDefault(); last.focus();
      } else if(!e.shiftKey && document.activeElement === last){
        e.preventDefault(); first.focus();
      }
    }
  }
  function open(){
    if(activeDrawer && activeDrawer !== api) activeDrawer.close();
    drawer.classList.add('drawer--open');
    btn.setAttribute('aria-expanded','true');
    onOpen && onOpen();
    focusables = [...drawer.querySelectorAll('a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])')];
    if(focusables[0]) focusables[0].focus();
    document.addEventListener('keydown',trap);
    activeDrawer = api;
  }
  function close(){
    drawer.classList.remove('drawer--open');
    btn.setAttribute('aria-expanded','false');
    document.removeEventListener('keydown',trap);
    btn.focus();
    if(activeDrawer === api) activeDrawer = null;
  }
  btn.addEventListener('click', () => {
    drawer.classList.contains('drawer--open') ? close() : open();
  });
  const api = {open, close};
  return api;
}

async function renderSeenList(){
  const grid = $("#seenGrid");
  grid.innerHTML = "";
  const ids = [...state.seen];
  for(const key of ids){
    const [typ,id] = key.split(/[-:]/);
    try{
      const t = await fetchJSON(`https://api.themoviedb.org/3/${typ}/${id}?api_key=${TMDB_KEY}&language=en-US`);
      t.genre_ids = (t.genres||[]).map(g=>g.id);
      const prev = state.type; state.type = typ;
      const c = card(t);
      state.type = prev;
      const footer = c.querySelector('.footer');
      const details = footer.querySelector('a');
      footer.innerHTML='';
      const rem = el('button',{className:'btn secondary',textContent:'Remove'});
      rem.addEventListener('click',()=>{
        state.seen.delete(key); saveSeen(); c.remove();
      });
      footer.append(rem, details);
      grid.appendChild(c);
    }catch(e){}
  }
}

// --- initial UI wiring
document.addEventListener("click",(e)=>{
  if(e.target.classList.contains("chip")) toggleChip(e.target);
});

const filterDrawerCtrl = setupDrawer("#filterDrawer", "#filtersBtn");
const seenDrawerCtrl = setupDrawer("#seenDrawer", "#seenBtn", renderSeenList);

$("#shuffleBtn").addEventListener("click", ()=> {
  filterDrawerCtrl.close();
  discover(true);
});
$("#findBtn").addEventListener("click", ()=> {
  filterDrawerCtrl.close();
  state.pageCursor = 1;
  discover(false);
});
$("#resetListsBtn").addEventListener("click",()=>{
  state.seen.clear();
  state.kept.clear();
  localStorage.removeItem("seenIds");
  localStorage.removeItem("keptIds");
  $("#seenGrid").innerHTML="";
  $("#results").innerHTML="";
});

// --- fetch TMDb genres & providers
async function fetchJSON(u){ const r = await fetch(u); if(!r.ok) throw new Error("HTTP " + r.status); return r.json(); }

async function loadGenres(){
  const [movieG, tvG] = await Promise.all([
    fetchJSON(`https://api.themoviedb.org/3/genre/movie/list?api_key=${TMDB_KEY}&language=en-US`),
    fetchJSON(`https://api.themoviedb.org/3/genre/tv/list?api_key=${TMDB_KEY}&language=en-US`)
  ]);
  state.genreMap.movie = Object.fromEntries(movieG.genres.map(g=>[String(g.id), g.name]));
  state.genreMap.tv    = Object.fromEntries(tvG.genres.map(g=>[String(g.id), g.name]));
  buildGenres();
}

function buildGenres(){
  const box = $("#genreChips"); box.innerHTML="";
  const map = state.genreMap[state.type];
  Object.entries(map).forEach(([id,name])=>{
    const c = el("div",{className:"chip", textContent:name}); c.dataset.value=id; box.appendChild(c);
  });
  state.genres = []; // reset when switching type
}

async function loadProvidersUS(){
  // weâ€™ll show subscription/free/ads services, US region
  const [pMovies, pTv] = await Promise.all([
    fetchJSON(`https://api.themoviedb.org/3/watch/providers/movie?api_key=${TMDB_KEY}&watch_region=US`),
    fetchJSON(`https://api.themoviedb.org/3/watch/providers/tv?api_key=${TMDB_KEY}&watch_region=US`)
  ]);

  const labels = {
    netflix: 'Netflix',
    prime: 'Prime Video',
    disney: 'Disney+',
    hulu: 'Hulu',
    max: 'Max',
    appletv: 'Apple TV+',
    paramount: 'Paramount+',
    peacock: 'Peacock',
    starz: 'STARZ',
    showtime: 'Showtime',
    amc: 'AMC+',
    criterion: 'Criterion Channel',
    freevee: 'Freevee',
    tubi: 'Tubi',
    pluto: 'Pluto TV',
  };

  const seen = new Map(); // slug -> {slug, provider_id, label}
  [...pMovies.results, ...pTv.results].forEach(p => {
    const slug = providerSlug(p.provider_name);
    if (!labels[slug]) return; // ignore providers we don't care about
    if (!seen.has(slug)) {
      seen.set(slug, { slug, provider_id: p.provider_id, label: labels[slug] });
    }
  });

  state.providersUS = [...seen.values()].sort((a, b) => a.label.localeCompare(b.label));
  buildProviders();
}

function buildProviders(){
  const box = $("#providerChips"); box.innerHTML="";
  state.chosenProviders.clear();
  state.providersUS.forEach(({provider_id, label})=>{
    const c = el("div",{className:"chip",textContent:label}); c.dataset.value=String(provider_id); box.appendChild(c);
  });
}

// --- discovery + enrichment
function buildDiscoverURL(page=1){
  const base = `https://api.themoviedb.org/3/discover/${state.type}?api_key=${TMDB_KEY}&language=en-US&include_adult=false&page=${page}`;
  const params = new URLSearchParams();
  // Streaming provider filter
  if(state.chosenProviders.size){
    // OR filter with pipes per TMDb docs; limit to subscription/ads/free
    params.set("with_watch_providers", [...state.chosenProviders].join("|"));
    params.set("watch_region","US");
    params.set("with_watch_monetization_types","flatrate|ads|free");
  }
  // Genres
  if(state.genres.length) params.set("with_genres", state.genres.join(","));

  // Release window
  const window = $("#releaseWindow").value;
  const now = new Date();
  const y = now.getFullYear();
  const add = (k,v)=>params.set(k,v);
  if(state.type==="movie"){
    if(window==="new"){ add("primary_release_date.gte", `${y-2}-01-01`); }
    else if(window==="recent"){ add("primary_release_date.gte","2015-01-01"); add("primary_release_date.lte","2021-12-31"); }
    else if(window==="classic"){ add("primary_release_date.lte","2014-12-31"); }
    // favor quality/popularity and real vote counts
    add("sort_by","popularity.desc");
    add("vote_count.gte","250");
  } else {
    if(window==="new"){ add("first_air_date.gte", `${y-2}-01-01`); }
    else if(window==="recent"){ add("first_air_date.gte","2015-01-01"); add("first_air_date.lte","2021-12-31"); }
    else if(window==="classic"){ add("first_air_date.lte","2014-12-31"); }
    add("sort_by","popularity.desc");
    add("vote_count.gte","100");
  }

  // Mood nudges via genres where possible
  const mood = $("#mood").value;
  const moodGenres = {
    feelgood: ["35","10751"],      // Comedy, Family
    intense:  ["53","28"],         // Thriller, Action
    smart:    ["18","99"],         // Drama, Documentary
    spooky:   ["27","9648"],       // Horror, Mystery
    actiony:  ["28","878","12"]  // Action, Sci-Fi, Adventure
  };
  if(mood && !state.genres.length && moodGenres[mood]) params.set("with_genres", moodGenres[mood].join(","));

  return base + "&" + params.toString();
}

// provider slug/class helper
async function enrichWithRatings(items){
  const out = [];
  // only enrich the first 12 results to keep API usage in check
  for (const it of items.slice(0,12)){
    try{
      const ext = await fetchJSON(`https://api.themoviedb.org/3/${state.type}/${it.id}/external_ids?api_key=${TMDB_KEY}`);
      const imdb = ext.imdb_id;
      let imdbRating=null, rtRating=null;
      if(imdb && OMDB_KEY){
        const om = await fetchJSON(`https://www.omdbapi.com/?apikey=${OMDB_KEY}&i=${imdb}&plot=short`);
        if(om && om.Ratings){
          (om.Ratings||[]).forEach(r=>{
            if(r.Source==="Internet Movie Database") imdbRating = r.Value;
            if(r.Source==="Rotten Tomatoes") rtRating = r.Value;
          });
        }
      }
      out.push({...it, imdbRating, rtRating});
    }catch(e){
      // on failure just include the original item
      out.push(it);
    }
  }
  // return enriched items followed by any remaining originals
  return out.concat(items.slice(12));
}

function card(t){
  const title = t.title || t.name;
  const year = (t.release_date||t.first_air_date||"").slice(0,4);
  const poster = t.poster_path ? `https://image.tmdb.org/t/p/w500${t.poster_path}` : "";
  const gmap = state.genreMap[state.type];
  const g = (t.genre_ids||[]).slice(0,3).map(id=>gmap[String(id)]).filter(Boolean);
  const rt = t.rtRating ? `ðŸ… ${t.rtRating}` : "";
  const imdb = t.imdbRating ? `IMDb ${t.imdbRating}` : (t.vote_average ? `TMDb ${t.vote_average.toFixed(1)}/10` : "");
  const detailsBtn = el("a",{textContent:"Details",href:`https://www.themoviedb.org/${state.type}/${t.id}`,target:"_blank",className:"btn",style:"text-align:center;text-decoration:none"});
  const seenBtn = el("button",{className:"btn secondary icon-btn",textContent:"âœ…",title:"Stream'd it!"});
  const keepBtn = el("button",{className:"btn secondary icon-btn",textContent:"ðŸ“Œ",title:"Keep it"});

  // provider badges HTML
  const provHTML = (t._providers||[]).map(p=>`<span class="prov-badge ${providerSlug(p)}">${p}</span>`).join("");

  const wrap = el("div",{className:"card"});
  wrap.dataset.id = String(t.id);
  if(state.kept.has(String(t.id))) wrap.classList.add("kept");
  wrap.innerHTML = `
    <img class="poster" alt="" src="${poster}">
    <div class="meta">
      <div class="title">${title} ${year?`<span class="sublabel">(${year})</span>`:""}</div>
      <div class="sublabel">${t.overview?.slice(0,180) ?? ""}${(t.overview||"").length>180?"â€¦":""}</div>
      <div class="badges">
        ${g.map(x=>`<span class="badge">${x}</span>`).join("")}
      </div>
      ${provHTML?`<div class="provline">${provHTML}</div>`:""}
      <div class="ratings">
        ${imdb?`<span class="badge">${imdb}</span>`:""}
        ${rt?`<span class="badge">${rt}</span>`:""}
      </div>
    </div>
    <div class="footer"></div>
  `;
  const footer = wrap.querySelector(".footer");
  footer.append(seenBtn, keepBtn, detailsBtn);

  seenBtn.addEventListener("click",()=>{
    const id = String(t.id);
    const key = `${state.type}-${id}`;
    state.seen.add(key);
    saveSeen();
    if(state.kept.delete(id)) saveKept();
    wrap.classList.add("seen");
    wrap.remove();
  });

  keepBtn.addEventListener("click",()=>{
    const id = String(t.id);
    if(state.kept.has(id)){
      state.kept.delete(id);
      wrap.classList.remove("kept");
    } else {
      state.kept.add(id);
      wrap.classList.add("kept");
    }
    saveKept();
  });
  return wrap;
}

async function attachProviders(items){
  // For each title, grab providers in US and show subscription/free badges
  for(const it of items){
    try{
      const pv = await fetchJSON(`https://api.themoviedb.org/3/${state.type}/${it.id}/watch/providers?api_key=${TMDB_KEY}`);
      const us = pv.results?.US;
      const names = new Set();
      ["flatrate","ads","free"].forEach(k => (us?.[k]||[]).forEach(p=>names.add(p.provider_name)));
      it._providers = [...names].slice(0,3);
    }catch(e){}
  }
  return items;
}

async function discover(nextPage=false){
  try{
    const grid = $("#results");
    const keptEls = [...grid.querySelectorAll(".card.kept")];
    const keptIdsOnPage = keptEls.map(el=>el.dataset.id);
    grid.innerHTML = "";
    keptEls.forEach(el=>grid.appendChild(el));
    toast(nextPage?"Shufflingâ€¦":"Finding optionsâ€¦");
    const url = buildDiscoverURL(nextPage ? ++state.pageCursor : (state.pageCursor=1));
    const data = await fetchJSON(url);
    let picks = (data.results || []).filter(p=>!state.seen.has(`${state.type}-${p.id}`) && !keptIdsOnPage.includes(String(p.id)));
    // enrich with ratings + provider badges
    picks = await enrichWithRatings(picks);
    // filter by IMDb threshold if available, else allow TMDb vote_average
    const min = parseFloat($("#minImdb").value);
    picks = picks.filter(p=>{
      const imdb = p.imdbRating ? parseFloat(p.imdbRating) : null;
      const tmdb = p.vote_average || 0;
      return (imdb && imdb >= min) || (!imdb && tmdb >= (min+0.5)); // slight grace if OMDb missing
    });
    picks = await attachProviders(picks);
    state.lastBatch = picks;
    if(!picks.length){ toast("No matchesâ€”try lowering the rating or adding providers."); return; }
    picks.slice(0,8).forEach(p => grid.appendChild(card(p)));
    toast(`Showing ${Math.min(8,picks.length)} of ${picks.length} matches`);
  }catch(e){
    toast("Oopsâ€”API error. Check keys and try again.");
    console.error(e);
  }
}

// boot
(async function init(){
  await Promise.all([loadGenres(), loadProvidersUS()]);
})();
</script>
</body>
</html>
